import {
  Fragment,
  computed,
  createVNode,
  defineComponent,
  getCurrentInstance,
  inject,
  isRef,
  mergeProps,
  provide,
  ref,
  shallowReactive,
  toRaw,
  unref,
  watch,
  watchEffect
} from "./chunk-HWWIPSMF.js";
import {
  __spreadProps,
  __spreadValues,
  define_process_env_default,
  init_define_process_env
} from "./chunk-KCDQCGWT.js";

// node_modules/vuetify/lib/composables/theme.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/index.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/animation.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/box.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/colorUtils.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/console.mjs
init_define_process_env();
function createMessage(message, vm, parent) {
  if (parent) {
    vm = {
      _isVue: true,
      $parent: parent,
      $options: vm
    };
  }
  if (vm) {
    vm.$_alreadyWarned = vm.$_alreadyWarned || [];
    if (vm.$_alreadyWarned.includes(message))
      return;
    vm.$_alreadyWarned.push(message);
  }
  return `[Vuetify] ${message}` + (vm ? generateComponentTrace(vm) : "");
}
function consoleWarn(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.warn(newMessage);
}
function consoleError(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.error(newMessage);
}
var classifyRE = /(?:^|[-_])(\w)/g;
var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function formatComponentName(vm, includeFile) {
  if (vm.$root === vm) {
    return "<Root>";
  }
  const options = typeof vm === "function" && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
  let name = options.name || options._componentTag;
  const file = options.__file;
  if (!name && file) {
    const match = file.match(/([^/\\]+)\.vue$/);
    name = match == null ? void 0 : match[1];
  }
  return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : "");
}
function generateComponentTrace(vm) {
  if (vm._isVue && vm.$parent) {
    const tree = [];
    let currentRecursiveSequence = 0;
    while (vm) {
      if (tree.length > 0) {
        const last = tree[tree.length - 1];
        if (last.constructor === vm.constructor) {
          currentRecursiveSequence++;
          vm = vm.$parent;
          continue;
        } else if (currentRecursiveSequence > 0) {
          tree[tree.length - 1] = [last, currentRecursiveSequence];
          currentRecursiveSequence = 0;
        }
      }
      tree.push(vm);
      vm = vm.$parent;
    }
    return "\n\nfound in\n\n" + tree.map((vm2, i) => `${i === 0 ? "---> " : " ".repeat(5 + i * 2)}${Array.isArray(vm2) ? `${formatComponentName(vm2[0])}... (${vm2[1]} recursive calls)` : formatComponentName(vm2)}`).join("\n");
  } else {
    return `

(found in ${formatComponentName(vm)})`;
  }
}

// node_modules/vuetify/lib/util/helpers.mjs
init_define_process_env();
function getNestedValue(obj, path, fallback) {
  const last = path.length - 1;
  if (last < 0)
    return obj === void 0 ? fallback : obj;
  for (let i = 0; i < last; i++) {
    if (obj == null) {
      return fallback;
    }
    obj = obj[path[i]];
  }
  if (obj == null)
    return fallback;
  return obj[path[last]] === void 0 ? fallback : obj[path[last]];
}
function deepEqual(a, b) {
  if (a === b)
    return true;
  if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
    return false;
  }
  if (a !== Object(a) || b !== Object(b)) {
    return false;
  }
  const props = Object.keys(a);
  if (props.length !== Object.keys(b).length) {
    return false;
  }
  return props.every((p) => deepEqual(a[p], b[p]));
}
function getObjectValueByPath(obj, path, fallback) {
  if (obj == null || !path || typeof path !== "string")
    return fallback;
  if (obj[path] !== void 0)
    return obj[path];
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  return getNestedValue(obj, path.split("."), fallback);
}
function createRange(length) {
  let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length
  }, (v, k) => start + k);
}
function convertToUnit(str) {
  let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (str == null || str === "") {
    return void 0;
  } else if (isNaN(+str)) {
    return String(str);
  } else if (!isFinite(+str)) {
    return void 0;
  } else {
    return `${Number(str)}${unit}`;
  }
}
function isObject(obj) {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
var keyCodes = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
var keyValues = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function wrapInArray(v) {
  return v == null ? [] : Array.isArray(v) ? v : [v];
}
function clamp(value) {
  let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(min, Math.min(max, value));
}
function mergeDeep() {
  let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  for (const key in source) {
    out[key] = source[key];
  }
  for (const key in target) {
    const sourceProperty = source[key];
    const targetProperty = target[key];
    if (isObject(sourceProperty) && isObject(targetProperty)) {
      out[key] = mergeDeep(sourceProperty, targetProperty);
      continue;
    }
    out[key] = targetProperty;
  }
  return out;
}
function getUid() {
  return getUid._uid++;
}
getUid._uid = 0;
function flattenFragments(nodes) {
  return nodes.map((node) => {
    if (node.type === Fragment) {
      return flattenFragments(node.children);
    } else {
      return node;
    }
  }).flat();
}
function toKebabCase() {
  let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
}
function wrapInRef(x) {
  return isRef(x) ? x : ref(x);
}
function findChildren(vnode) {
  if (!vnode || typeof vnode !== "object") {
    return [];
  }
  if (Array.isArray(vnode)) {
    return vnode.map((child) => findChildren(child)).filter((v) => v).flat(1);
  } else if (Array.isArray(vnode.children)) {
    return vnode.children.map((child) => findChildren(child)).filter((v) => v).flat(1);
  } else if (vnode.component) {
    var _vnode$component;
    return [vnode.component, ...findChildren((_vnode$component = vnode.component) == null ? void 0 : _vnode$component.subTree)].filter((v) => v).flat(1);
  }
  return [];
}

// node_modules/vuetify/lib/util/color/transformSRGB.mjs
init_define_process_env();
var srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
var srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
var srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
var srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
function fromXYZ(xyz) {
  const rgb = Array(3);
  const transform = srgbForwardTransform;
  const matrix = srgbForwardMatrix;
  for (let i = 0; i < 3; ++i) {
    rgb[i] = Math.round(clamp(transform(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
  }
  return (rgb[0] << 16) + (rgb[1] << 8) + (rgb[2] << 0);
}
function toXYZ(rgb) {
  const xyz = [0, 0, 0];
  const transform = srgbReverseTransform;
  const matrix = srgbReverseMatrix;
  const r = transform((rgb >> 16 & 255) / 255);
  const g = transform((rgb >> 8 & 255) / 255);
  const b = transform((rgb >> 0 & 255) / 255);
  for (let i = 0; i < 3; ++i) {
    xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;
  }
  return xyz;
}

// node_modules/vuetify/lib/util/color/transformCIELAB.mjs
init_define_process_env();
var delta = 0.20689655172413793;
var cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
var cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
function fromXYZ2(xyz) {
  const transform = cielabForwardTransform;
  const transformedY = transform(xyz[1]);
  return [116 * transformedY - 16, 500 * (transform(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform(xyz[2] / 1.08883))];
}
function toXYZ2(lab) {
  const transform = cielabReverseTransform;
  const Ln = (lab[0] + 16) / 116;
  return [transform(Ln + lab[1] / 500) * 0.95047, transform(Ln), transform(Ln - lab[2] / 200) * 1.08883];
}

// node_modules/vuetify/lib/util/colorUtils.mjs
function isCssColor(color) {
  return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
function colorToInt(color) {
  let rgb;
  if (typeof color === "number") {
    rgb = color;
  } else if (typeof color === "string") {
    let c = color.startsWith("#") ? color.substring(1) : color;
    if (c.length === 3) {
      c = c.split("").map((char) => char + char).join("");
    }
    if (c.length !== 6) {
      consoleWarn(`'${color}' is not a valid rgb color`);
    }
    rgb = parseInt(c, 16);
  } else {
    throw new TypeError(`Colors can only be numbers or strings, recieved ${color == null ? color : color.constructor.name} instead`);
  }
  if (rgb < 0) {
    consoleWarn(`Colors cannot be negative: '${color}'`);
    rgb = 0;
  } else if (rgb > 16777215 || isNaN(rgb)) {
    consoleWarn(`'${color}' is not a valid rgb color`);
    rgb = 16777215;
  }
  return rgb;
}
function intToHex(color) {
  let hexColor = color.toString(16);
  if (hexColor.length < 6)
    hexColor = "0".repeat(6 - hexColor.length) + hexColor;
  return "#" + hexColor;
}
function colorToRGB(color) {
  const int = colorToInt(color);
  return {
    r: (int & 16711680) >> 16,
    g: (int & 65280) >> 8,
    b: int & 255
  };
}
function lighten(value, amount) {
  const lab = fromXYZ2(toXYZ(value));
  lab[0] = lab[0] + amount * 10;
  return fromXYZ(toXYZ2(lab));
}
function darken(value, amount) {
  const lab = fromXYZ2(toXYZ(value));
  lab[0] = lab[0] - amount * 10;
  return fromXYZ(toXYZ2(lab));
}
function getLuma(color) {
  const rgb = colorToInt(color);
  return toXYZ(rgb)[1];
}

// node_modules/vuetify/lib/util/createSimpleFunctional.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/defineComponent.mjs
init_define_process_env();

// node_modules/vuetify/lib/composables/defaults.mjs
init_define_process_env();
var DefaultsSymbol = Symbol.for("vuetify:defaults");
function createDefaults(options) {
  return ref(options != null ? options : {});
}
function useDefaults() {
  const defaults = inject(DefaultsSymbol);
  if (!defaults)
    throw new Error("[Vuetify] Could not find defaults instance");
  return defaults;
}
function provideDefaults(defaults, options) {
  const injectedDefaults = useDefaults();
  const providedDefaults = ref(defaults);
  const newDefaults = computed(() => {
    const scoped = unref(options == null ? void 0 : options.scoped);
    const reset = unref(options == null ? void 0 : options.reset);
    const root = unref(options == null ? void 0 : options.root);
    let properties = mergeDeep(providedDefaults.value, {
      prev: injectedDefaults.value
    });
    if (scoped)
      return properties;
    if (reset || root) {
      const len = Number(reset || Infinity);
      for (let i = 0; i <= len; i++) {
        if (!properties.prev)
          break;
        properties = properties.prev;
      }
      return properties;
    }
    return mergeDeep(properties, properties.prev);
  });
  provide(DefaultsSymbol, newDefaults);
  return newDefaults;
}

// node_modules/vuetify/lib/util/defineComponent.mjs
function propIsDefined(vnode, prop) {
  var _vnode$props, _vnode$props2;
  return ((_vnode$props = vnode.props) == null ? void 0 : _vnode$props.hasOwnProperty(prop)) || ((_vnode$props2 = vnode.props) == null ? void 0 : _vnode$props2.hasOwnProperty(toKebabCase(prop)));
}
var defineComponent2 = function defineComponent3(options) {
  var _options$_setup;
  options._setup = (_options$_setup = options._setup) != null ? _options$_setup : options.setup;
  if (!options.name) {
    consoleWarn("The component is missing an explicit name, unable to generate default prop value");
    return options;
  }
  if (options._setup) {
    options.setup = function setup(props, ctx) {
      const vm = getCurrentInstance();
      const defaults = useDefaults();
      const _props = shallowReactive(__spreadValues({}, toRaw(props)));
      watchEffect(() => {
        const globalDefaults = defaults.value.global;
        const componentDefaults = defaults.value[options.name];
        for (const prop of Object.keys(props)) {
          let newVal;
          if (propIsDefined(vm.vnode, prop)) {
            newVal = props[prop];
          } else {
            var _ref, _componentDefaults$pr;
            newVal = (_ref = (_componentDefaults$pr = componentDefaults == null ? void 0 : componentDefaults[prop]) != null ? _componentDefaults$pr : globalDefaults == null ? void 0 : globalDefaults[prop]) != null ? _ref : props[prop];
          }
          if (_props[prop] !== newVal) {
            _props[prop] = newVal;
          }
        }
      });
      return options._setup(_props, ctx);
    };
  }
  return options;
};
function genericComponent() {
  let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  return (options) => (exposeDefaults ? defineComponent2 : defineComponent)(options);
}

// node_modules/vuetify/lib/util/dom.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/easing.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/getCurrentInstance.mjs
init_define_process_env();
function getCurrentInstance2(name, message) {
  const vm = getCurrentInstance();
  if (!vm) {
    throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
  }
  return vm;
}
function getCurrentInstanceName() {
  var _getCurrentInstance$t;
  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  return toKebabCase((_getCurrentInstance$t = getCurrentInstance2(name).type) == null ? void 0 : _getCurrentInstance$t.name);
}

// node_modules/vuetify/lib/util/getScrollParent.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/globals.mjs
init_define_process_env();
var IS_NODE = typeof process !== "undefined";
var IN_BROWSER = typeof window !== "undefined";
var IS_DEBUG = IS_NODE && define_process_env_default.DEBUG === "true";
var SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
var SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
var SUPPORTS_FOCUS_VISIBLE = IN_BROWSER && CSS.supports("selector(:focus-visible)");

// node_modules/vuetify/lib/util/isFixedPosition.mjs
init_define_process_env();

// node_modules/vuetify/lib/util/propsFactory.mjs
init_define_process_env();
function propsFactory(props, source) {
  return (defaults) => {
    return Object.keys(props).reduce((obj, prop) => {
      const isObjectDefinition = typeof props[prop] === "object" && props[prop] != null && !Array.isArray(props[prop]);
      const definition = isObjectDefinition ? props[prop] : {
        type: props[prop]
      };
      if (defaults && prop in defaults) {
        obj[prop] = __spreadProps(__spreadValues({}, definition), {
          default: defaults[prop]
        });
      } else {
        obj[prop] = definition;
      }
      if (source) {
        obj[prop].source = source;
      }
      return obj;
    }, {});
  };
}

// node_modules/vuetify/lib/util/useRender.mjs
init_define_process_env();
function useRender(render) {
  const vm = getCurrentInstance2("useRender");
  vm.render = render;
}

// node_modules/vuetify/lib/util/color/APCA.mjs
init_define_process_env();
var mainTRC = 2.4;
var Rco = 0.2126729;
var Gco = 0.7151522;
var Bco = 0.072175;
var normBG = 0.55;
var normTXT = 0.58;
var revTXT = 0.57;
var revBG = 0.62;
var blkThrs = 0.03;
var blkClmp = 1.45;
var deltaYmin = 5e-4;
var scaleBoW = 1.25;
var scaleWoB = 1.25;
var loConThresh = 0.078;
var loConFactor = 12.82051282051282;
var loConOffset = 0.06;
var loClip = 1e-3;
function APCAcontrast(text, background) {
  const Rtxt = ((text >> 16 & 255) / 255) ** mainTRC;
  const Gtxt = ((text >> 8 & 255) / 255) ** mainTRC;
  const Btxt = ((text >> 0 & 255) / 255) ** mainTRC;
  const Rbg = ((background >> 16 & 255) / 255) ** mainTRC;
  const Gbg = ((background >> 8 & 255) / 255) ** mainTRC;
  const Bbg = ((background >> 0 & 255) / 255) ** mainTRC;
  let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
  let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
  if (Ytxt <= blkThrs)
    Ytxt += (blkThrs - Ytxt) ** blkClmp;
  if (Ybg <= blkThrs)
    Ybg += (blkThrs - Ybg) ** blkClmp;
  if (Math.abs(Ybg - Ytxt) < deltaYmin)
    return 0;
  let outputContrast;
  if (Ybg > Ytxt) {
    const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
    outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
  } else {
    const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
    outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
  }
  return outputContrast * 100;
}

// node_modules/vuetify/lib/composables/theme.mjs
var ThemeSymbol = Symbol.for("vuetify:theme");
var makeThemeProps = propsFactory({
  theme: String
}, "theme");
var defaultThemeOptions = {
  defaultTheme: "light",
  variations: {
    colors: [],
    lighten: 0,
    darken: 0
  },
  themes: {
    light: {
      dark: false,
      colors: {
        background: "#FFFFFF",
        surface: "#FFFFFF",
        "surface-variant": "#424242",
        "on-surface-variant": "#EEEEEE",
        primary: "#6200EE",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC6",
        "secondary-darken-1": "#018786",
        error: "#B00020",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#000000",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "idle-opacity": 0.04,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.12,
        "dragged-opacity": 0.08,
        "kbd-background-color": "#212529",
        "kbd-color": "#FFFFFF",
        "code-background-color": "#C2C2C2"
      }
    },
    dark: {
      dark: true,
      colors: {
        background: "#121212",
        surface: "#212121",
        "surface-variant": "#BDBDBD",
        "on-surface-variant": "#424242",
        primary: "#BB86FC",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC5",
        "secondary-darken-1": "#03DAC5",
        error: "#CF6679",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#FFFFFF",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "idle-opacity": 0.1,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.16,
        "dragged-opacity": 0.08,
        "kbd-background-color": "#212529",
        "kbd-color": "#FFFFFF",
        "code-background-color": "#B7B7B7"
      }
    }
  }
};
var parseThemeOptions = function() {
  var _options$themes;
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultThemeOptions;
  if (!options)
    return __spreadProps(__spreadValues({}, defaultThemeOptions), {
      isDisabled: true
    });
  const themes = Object.entries((_options$themes = options.themes) != null ? _options$themes : {}).reduce((obj, _ref) => {
    var _defaultThemeOptions$, _defaultThemeOptions$2;
    let [key, theme] = _ref;
    const defaultTheme = theme.dark ? (_defaultThemeOptions$ = defaultThemeOptions.themes) == null ? void 0 : _defaultThemeOptions$.dark : (_defaultThemeOptions$2 = defaultThemeOptions.themes) == null ? void 0 : _defaultThemeOptions$2.light;
    obj[key] = mergeDeep(defaultTheme, theme);
    return obj;
  }, {});
  return mergeDeep(defaultThemeOptions, __spreadProps(__spreadValues({}, options), {
    themes
  }));
};
function createTheme(app, options) {
  const head = app._context.provides.usehead;
  const parsedOptions = parseThemeOptions(options);
  const styleEl = ref();
  const current = ref(parsedOptions.defaultTheme);
  const themes = ref(parsedOptions.themes);
  const variations = ref(parsedOptions.variations);
  const computedThemes = computed(() => {
    return Object.entries(themes.value).reduce((obj, _ref2) => {
      var _parsedOptions$variat;
      let [name, original] = _ref2;
      const theme = __spreadProps(__spreadValues({}, original), {
        colors: __spreadValues(__spreadValues({}, original.colors), ((_parsedOptions$variat = parsedOptions.variations.colors) != null ? _parsedOptions$variat : []).reduce((obj2, color) => {
          return __spreadValues(__spreadValues({}, obj2), genColorVariations(color, original.colors[color]));
        }, {}))
      });
      for (const color of Object.keys(theme.colors)) {
        if (/on-[a-z]/.test(color) || theme.colors[`on-${color}`])
          continue;
        const onColor = `on-${color}`;
        const colorVal = colorToInt(theme.colors[color]);
        const blackContrast = Math.abs(APCAcontrast(0, colorVal));
        const whiteContrast = Math.abs(APCAcontrast(16777215, colorVal));
        theme.colors[onColor] = whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
      }
      obj[name] = theme;
      return obj;
    }, {});
  });
  function genColorVariations(name, color) {
    const obj = {};
    for (const variation of ["lighten", "darken"]) {
      const fn = variation === "lighten" ? lighten : darken;
      for (const amount of createRange(variations.value[variation], 1)) {
        obj[`${name}-${variation}-${amount}`] = intToHex(fn(colorToInt(color), amount));
      }
    }
    return obj;
  }
  const styles = computed(() => {
    const lines = [];
    for (const themeName of Object.keys(computedThemes.value)) {
      const variables = computedThemes.value[themeName].variables;
      lines.push(...createCssClass(`.v-theme--${themeName}`, [...genCssVariables(themeName), ...Object.keys(variables).map((key) => {
        const value = variables[key];
        const color = typeof value === "string" && value.startsWith("#") ? colorToRGB(value) : void 0;
        const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
        return `--v-${key}: ${rgb != null ? rgb : value}`;
      })]));
    }
    const colors = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
    for (const key of colors) {
      if (/on-[a-z]/.test(key)) {
        lines.push(...createCssClass(`.${key}`, [`color: rgb(var(--v-theme-${key})) !important`]));
      } else {
        lines.push(...createCssClass(`.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`]), ...createCssClass(`.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`]), ...createCssClass(`.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]));
      }
    }
    return lines.map((str, i) => i === 0 ? str : `    ${str}`).join("");
  });
  function genCssVariables(name) {
    const theme = computedThemes.value[name];
    if (!theme)
      throw new Error(`Could not find theme ${name}`);
    const lightOverlay = theme.dark ? 2 : 1;
    const darkOverlay = theme.dark ? 1 : 2;
    const variables = [];
    for (const [key, value] of Object.entries(theme.colors)) {
      const rgb = colorToRGB(value);
      variables.push(`--v-theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);
      if (!key.startsWith("on-")) {
        variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
      }
    }
    return variables;
  }
  function createCssClass(selector, content) {
    return [`${selector} {
`, ...content.map((line) => `  ${line};
`), "}\n"];
  }
  if (head) {
    head.addHeadObjs(computed(() => ({
      style: [{
        children: styles.value,
        type: "text/css",
        id: "vuetify-theme-stylesheet"
      }]
    })));
    if (IN_BROWSER) {
      watchEffect(() => head.updateDOM());
    }
  } else {
    let updateStyles = function() {
      if (parsedOptions.isDisabled)
        return;
      genStyleElement();
      if (styleEl.value)
        styleEl.value.innerHTML = styles.value;
    }, genStyleElement = function() {
      if (typeof document === "undefined" || styleEl.value)
        return;
      const el = document.createElement("style");
      el.type = "text/css";
      el.id = "vuetify-theme-stylesheet";
      styleEl.value = el;
      document.head.appendChild(styleEl.value);
    };
    watch(themes, updateStyles, {
      deep: true,
      immediate: true
    });
  }
  return {
    isDisabled: parsedOptions.isDisabled,
    themes: computedThemes,
    setTheme: (key, theme) => themes.value[key] = theme,
    getTheme: (key) => computedThemes.value[key],
    current,
    themeClasses: computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${current.value}`),
    styles
  };
}
function provideTheme(props) {
  getCurrentInstance2("provideTheme");
  const theme = inject(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  const current = computed(() => {
    var _props$theme;
    return (_props$theme = props.theme) != null ? _props$theme : theme == null ? void 0 : theme.current.value;
  });
  const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${current.value}`);
  const newTheme = __spreadProps(__spreadValues({}, theme), {
    current,
    themeClasses
  });
  provide(ThemeSymbol, newTheme);
  return newTheme;
}
function useTheme() {
  getCurrentInstance2("useTheme");
  const theme = inject(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  return theme;
}

// node_modules/vuetify/lib/composables/icons.mjs
init_define_process_env();
var IconSymbol = Symbol.for("vuetify:icons");
var makeIconProps = propsFactory({
  icon: {
    type: [String, Object],
    required: true
  },
  tag: {
    type: String,
    required: true
  }
}, "icon");
var VComponentIcon = defineComponent2({
  name: "VComponentIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, null, {
        default: () => [createVNode(props.icon, null, null)]
      });
    };
  }
});
var VSvgIcon = defineComponent2({
  name: "VSvgIcon",
  inheritAttrs: false,
  props: makeIconProps(),
  setup(props, _ref) {
    let {
      attrs
    } = _ref;
    return () => {
      return createVNode(props.tag, mergeProps(attrs, {
        "style": null
      }), {
        default: () => [createVNode("svg", {
          "class": "v-icon__svg",
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": "0 0 24 24",
          "role": "img",
          "aria-hidden": "true"
        }, [createVNode("path", {
          "d": props.icon
        }, null)])]
      });
    };
  }
});
var VLigatureIcon = defineComponent2({
  name: "VLigatureIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, null, {
        default: () => [props.icon]
      });
    };
  }
});
var VClassIcon = defineComponent2({
  name: "VClassIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, {
        "class": props.icon
      }, null);
    };
  }
});
var defaultSets = {
  svg: {
    component: VSvgIcon
  },
  class: {
    component: VClassIcon
  }
};
var useIcon = (props) => {
  const icons = inject(IconSymbol);
  if (!icons)
    throw new Error("Missing Vuetify Icons provide!");
  const iconData = computed(() => {
    const iconAlias = isRef(props) ? props.value : props.icon;
    if (!iconAlias)
      throw new Error("Icon value is undefined or null");
    let icon = iconAlias;
    if (typeof iconAlias === "string" && iconAlias.includes("$")) {
      var _icons$aliases;
      icon = (_icons$aliases = icons.aliases) == null ? void 0 : _icons$aliases[iconAlias.slice(iconAlias.indexOf("$") + 1)];
    }
    if (!icon)
      throw new Error(`Could not find aliased icon "${iconAlias}"`);
    if (typeof icon !== "string") {
      return {
        component: VComponentIcon,
        icon
      };
    }
    const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
    const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
    const iconSet = icons.sets[iconSetName != null ? iconSetName : icons.defaultSet];
    return {
      component: iconSet.component,
      icon: iconName
    };
  });
  return {
    iconData
  };
};

export {
  consoleWarn,
  consoleError,
  deepEqual,
  getObjectValueByPath,
  convertToUnit,
  isObject,
  keyCodes,
  wrapInArray,
  mergeDeep,
  getUid,
  flattenFragments,
  toKebabCase,
  wrapInRef,
  findChildren,
  isCssColor,
  DefaultsSymbol,
  createDefaults,
  provideDefaults,
  defineComponent2 as defineComponent,
  genericComponent,
  getCurrentInstance2 as getCurrentInstance,
  getCurrentInstanceName,
  IN_BROWSER,
  SUPPORTS_TOUCH,
  propsFactory,
  useRender,
  ThemeSymbol,
  makeThemeProps,
  createTheme,
  provideTheme,
  useTheme,
  IconSymbol,
  VClassIcon,
  defaultSets,
  useIcon
};
//# sourceMappingURL=chunk-WBH7DMGX.js.map
